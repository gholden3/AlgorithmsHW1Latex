% me=0 student solutions (ps file), me=1 - my solutions (sol file),
% me=2 - assignment (hw file)
\def\me{0} \def\num{1} %homework number

\def\assigned{May 27, 2020} %due date
\def\due{5 pm on Thursday, June 4, 2020} %due date

\def\course{CSCI-GA.1170-001/002 Fundamental Algorithms} 
%course name, changed only once

% **** INSERT YOUR NAME HERE ****
\def\name{Gina Holden}

% **** INSERT YOUR NETID HERE ****
\def\netid{gh1407}

% **** INSERT NETIDs OF YOUR COLLABORATORS HERE ****
\def\collabs{}


\iffalse

INSTRUCTIONS: replace # by the homework number.  (if this is not
ps#.tex, use the right file name)

Clip out the ********* INSERT HERE ********* bits below and insert
appropriate LaTeX code.  There is a section below for student macros.
It is not recommended to change any other parts of the code.


\fi
%

\documentclass[11pt]{article}


% ==== Packages ====
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}

% \setlength{\oddsidemargin}{.0in} \setlength{\evensidemargin}{.0in}
% \setlength{\textwidth}{6.5in} \setlength{\topmargin}{-0.4in}
\setlength{\footskip}{1in} \setlength{\textheight}{8.5in}

\newcommand{\commentt}[1]{}

\newcommand{\handout}[5]{
\renewcommand{\thepage}{#1, Page \arabic{page}}
  \noindent
  \begin{center}
    \framebox{ \vbox{ \hbox to 5.78in { {\bf \course} \hfill #2 }
        \vspace{4mm} \hbox to 5.78in { {\Large \hfill #5 \hfill} }
        \vspace{2mm} \hbox to 5.78in { {\it #3 \hfill #4} }
        \ifnum\me=0
        \vspace{2mm} \hbox to 5.78in { {\it Collaborators: \collabs
            \hfill} }
        \fi
      } }
  \end{center}
  \vspace*{4mm}
}

\newcounter{pppp}
\newcommand{\prob}{\arabic{pppp}} %problem number
\newcommand{\increase}{\addtocounter{pppp}{1}} %problem number

% Arguments: Title, Number of Points
\newcommand{\newproblem}[2]{
  \ifnum\me=0
    \ifnum\prob>0 \newpage \fi
    \increase
    \setcounter{page}{1}
    \handout{\name{} (\netid), Homework \num, Problem \arabic{pppp}}
    {\assigned}{Name: \name{} (\netid)}{Due: \due}
    {Solutions to Problem \prob\ of Homework \num\ (#2)}
  \else
    \increase
    \section*{Problem \num-\prob~(#1) \hfill {#2}}
  \fi
}

% \newcommand{\newproblem}[2]{\increase
% \section*{Problem \num-\prob~(#1) \hfill {#2}}
% }

\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\qed{\hspace*{\fill}
  \vbox{\hrule\hbox{\vrule\squarebox{.667em}\vrule}\hrule}}
\newenvironment{solution}{\begin{trivlist}\item[]{\bf Solution:}}
  {\qed \end{trivlist}}
\newenvironment{solsketch}{\begin{trivlist}\item[]{\bf Solution
      Sketch:}} {\qed \end{trivlist}}
\newenvironment{code}{\begin{tabbing}
    12345\=12345\=12345\=12345\=12345\=12345\=12345\=12345\= \kill }
  {\end{tabbing}}

%\newcommand{\eqref}[1]{Equation~(\ref{eq:#1})}

\newcommand{\hint}[1]{({\bf Hint}: {#1})}
% Put more macros here, as needed.
\newcommand{\room}{\medskip\ni}
\newcommand{\brak}[1]{\langle #1 \rangle}
\newcommand{\bit}[1]{\{0,1\}^{#1}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\C}{{\cal C}}

\newcommand{\nin}{\not\in}
\newcommand{\set}[1]{\{#1\}}
\renewcommand{\ni}{\noindent}
\renewcommand{\gets}{\leftarrow}
\renewcommand{\to}{\rightarrow}
\newcommand{\assign}{:=}

\newcommand{\AND}{\wedge}
\newcommand{\OR}{\vee}

\newcommand{\For}{\mbox{\bf for }}
\newcommand{\To}{\mbox{\bf to }}
\newcommand{\Do}{\mbox{\bf do }}
\newcommand{\If}{\mbox{\bf if }}
\newcommand{\Then}{\mbox{\bf then }}
\newcommand{\Else}{\mbox{\bf else }}
\newcommand{\While}{\mbox{\bf while }}
\newcommand{\Repeat}{\mbox{\bf repeat }}
\newcommand{\Until}{\mbox{\bf until }}
\newcommand{\Return}{\mbox{\bf return }}
\newcommand{\Halt}{\mbox{\bf halt }}
\newcommand{\Swap}{\mbox{\bf swap }}
\newcommand{\Ex}[2]{\textrm{exchange } #1 \textrm{ with } #2}



\begin{document}

\ifnum\me=0

% Collaborators (on a per task basis):
%
% Task 1: *********** INSERT COLLABORATORS HERE *********** 
% Task 2: *********** INSERT COLLABORATORS HERE *********** 
% etc.
%

\fi

\ifnum\me=1

\handout{PS \num}{\assigned}{Lecturer: Richard Hull}{Due: \due}
{Solution {\em Sketches} to Problem Set \num}

\fi

\ifnum\me=2

\handout{PS \num}{\assigned}{Lecturer: Richard Hull}{Due: \due}{Problem
  Set \num}

\fi



%======================================

\newproblem{Insertion Sort with Binary Search}{14 points}

In the lecture we discussed a variation on Insertion Sort, in which the insertion step was performed by using a Binary Search. 
This exercise explores that approach more deeply.
(In particular, there are some details that I didn't think of during the lecture.)

As with the Insertion Sort algorithm presented in the lecture and in CLRS, assume that the initial unsorted list is presented in an array.


\begin{itemize}
\item[(a)] (4 points) 
Assume that the only data structure available to you is arrays (i.e., no linked lists).
Assume further that you maintain the partial set of already sorted elements in an array.
Write pseudo-code for an algorithm that performs Insertion Sort and uses Binary Search as the mechanism for identifying where to insert each new element being considered.
Pay special attention to 
\begin{itemize}
    \item[(i)] The Binary Search algorithm itself
    \item[(ii)] The specific algorithm used to insert an element into the already sorted list, once you know where it should be inserted.
\end{itemize}

\ifnum\me<2
\begin{solution} 

\begin{code}

binary-search-2(array, value, min-idx, max-idx):\\
1\> $\backslash$$\backslash$ stop condition\\
2\> \If max-idx $\leq$ min-idx:  \\
3\>\>    \If value $>$ array[min-idx]:\\
4\>\>\>      \Return min-idx + 1\\
5\>\>\Return min-idx\\
6\>mid-idx = floor((min-idx + max-idx) / 2))\\
7\> \If(value == array[mid-idx]):\\
8\>\>\Return mid+1\\
9\> \If(item $>$ array[mid-idx]): \\
10\>\> $\backslash$$\backslash$ search right\\
11\>\>       $\Return$ binary-search(array, value, mid-idx+1, max-idx)\\
12\> $\backslash$$\backslash$ search left\\
13\>    $\Return$ binary-search(array, value, min-idx, max-idx -1);\\ \\ \\ \\ \\ \\ \\

binary-search(array, min-idx, max-idx, value):\\
1\> \While (min-idx $\leq$ max-idx):\\
2\> \>  mid-idx = min-idx + floor((max-idx - min-idx) / 2)\\
3\> \>       // Check if the middle is value\\
4\> \>        \If (array[mid-idx] == value) \\
5\> \> \>            \Return mid-idx\\
6\> \>       // If value greater, search right \\
7\> \>        \If (array[mid-idx] $<$ value):\\
8\> \> \>             min-idx = mid-idx + 1\\
9\> \>      // If value is smaller, search left\\
10\> \>        \Else:\\
11\> \>\>            max-idx = mid-idx - 1\\
12\>     \If value $>$ array[min-idx]:\\
13\>\>      \Return min-idx + 1\\
14\>\Return min-idx\\ \\ \\




insertion-sort(array): \\
\> \For j = 2 $\to$ array.length\\
\> \>key = array[j]\\
\> \> i = j - 1\\
\> \> $\backslash$$\backslash$ find idx for insertion \\
\> \> loc = binary-search(array, key, 0, i); \\
\> \> $\backslash$$\backslash$ shift everything over\\
\>  \>      $\While$ (i $\geq$ loc) :\\
\> \> \>      array[i+1] = a[i]\\
\> \>   \>         i = i - 1 \\
\> \>      array[loc] = key 


\end{code}

\end{solution}
\fi

\item[(b)] (3 points) 
Write a loop invariant that characterizes the behavior of the Binary Search component of your algorithm from part (a)
\ifnum\me<2
	\fi
\ifnum\me<2
\begin{solution} 

I originally implemented binary search using recursion (function binary-search-2) but upon reading this question I realized we haven't learned how to do loop invariants with recursion so then I implemented binary search again for the iterative version (function binary-search).

\textbf{Loop invariant}: At the start of each iteration of the while loop in lines 1-10, the subarray array[min-idx..max-idx] contains all of the original values in original positions of array but the min-idx and max-idx provide a lower and upper bound on the index where value should be placed. The size of this bound, that is max-idx - min-idx, halves after each iteration, creating a tighter and tighter bound on the range of possible indeces where value should be placed. 

\end{solution}
\fi

\item[(c)] (3 points)
What is the worst-case running time for performing one instance of part
(a.ii) of your algorithm (expressed in 
$\Theta$ notation?
Express this in terms of $m$ where $m$ is the number of elements that have already been sorted.

\ifnum\me<2
	\fi
\ifnum\me<2
\begin{solution}  
$\Theta$(m)  
\end{solution}
\fi

\item[(d)] (4 points)
Given that Binary Search takes $\Theta(\lg n)$, and 
based on your analysis for part (c), what is the worst case running time of your algorithm (in $\Theta$ notation)?  Justify your answer.

\ifnum\me<2
	\fi
\ifnum\me<2
\begin{solution}\\   
For each element n, we need to perform the binary search ($\Theta(\lg n)$), then we need to shuffle every previous element over in the worst case (sum of 1.. n). so we have: \\
$\Theta (n\lg n)$ + 1/2n(n+1)=\\
$\Theta (n\lg n)$ + $\Theta (n^2)$=
$\Theta (n^2)$
\end{solution}
\fi


\end{itemize}



%======================================

\newproblem{Inversions and Sorting}{18 points}
%%%%%%%%%{24+2 points}

\noindent
Let $A[1, \ldots, n]$ be an array of $n$ distinct numbers.  If $i < j$
and $A[i] > A[j]$, then the pair $(i,j)$ is called an \emph{inversion}
of $A$. It is often instructive to analyze the sorting
algorithms through inversions.  

\begin{enumerate}
 \item[(a)] (1 point) List all inversions of the array
  $\langle 22,15,13,17,10 \rangle$.

  \ifnum\me<2
\begin{solution}   
(0,1), (0,2), (0,3), (0,4), (1,2), (1,4), (2,4), (3, 4)
\end{solution}
  \fi

  \item[(b)] (2 points) Which arrays with distinct elements from the
  set $\{1,2,\ldots, n\}$ have the smallest and the largest number of
  inversions and why?  State the expressions {\em exactly} in terms of
  $n$.

  \ifnum\me<2
\begin{solution}  

The largest number of inversions is when the array is sorted in decreasing order (descending). In this case, the number of inversions is (n-1) + (n-2) + ... + 1 which sums to: 1/2(n)(n+1) - n 

The smallest number of inversions is when the array is sorted in increasing order. The number of inversions is 0. 

\end{solution}
  \fi

\item [(c)] (3 points) Show that an array where no two elements form an	inversion is sorted in non-decreasing order. 
	\ifnum\me<2
\begin{solution} \\  
To think about this, we can prove that insertion sort removes all inversions. Take a starting array that is populated with distinct elements from the set {1, 2, ..., n } as in section (a), all in decreasing order. Here, as mentioned in section (b), there are (n-1) + (n-2) + ... + 1 inversions.\\
Now when we insert the first element into the left array, since the array was originally descending, we know we need to shuffle 1 element over to make room. This decreases the number of inversions by one. Next iteration, we need to shuffle over exactly two elements in order to make room for the new element which removes 2 inversions. We can see the number of inversions removed is 1+ 2 + ... + (n-1) which equals the original number of inversions. 

\end{solution}
	\fi
	\item [(d)] (4 points) Show that swapping an inversion of $A$ strictly decreases the
	number of inversions in $A$. 
	\ifnum\me<2
\begin{solution}   
 Swapping an inversion can only ever decrease the number of inversions because swapping an inversion means moving the higher number to the right and the lower number to the left of the array. Lets take a sample array with some values a-h: 
  [a, b, c, d, e, f, g, h]
 Say high number was at index 3 (d) and low number was at index 6 (g) originally. For the explanation, let us consider the three ranges of numbers: those in index 0-2(a-c), those in 4-5 (e-f), and those in 6+ (h). 
 
 For the first range (a-c): any number lower than g was already not an inversion so moving the lower number left has no effect. Any number higher than g was already counted as an inversion and the same number of inversions exist unchanged when g is moved left into index 3. With respect to the higher number (d), any a-c that was lower than d was previously not an inversion and remains not an inversion. Any number higher than d was previously counted as an inversion and remains an inversion. Therefore no inversion counts change for any index before the swap index. 
 
 For the second range (e-f): any number lower than g was previously not an inversion but now is with respect to g. This is counteracted by the fact that when you move the high number (d) right, these pairs were previously inversions but are now not inversions with respect to g. Therefore the inversion changes in this middle range cancel each other out. 
 
 The final range, which is after the swap (h+), is similar to the first range in that no inversion counts change with respect to the two elements that were swapped. Any previous inversion remains and no new inversions are created because the items that were swapped remain to the left of this range. 
 
 Therefore there is no change in inversions for any value to the left, between, or to the right of the two elements being swapped. The only values left to consider are the values being swapped which decreases the number of inversions by exactly one. 
 
 
\end{solution}
	\fi
	\item[(e)] (3 points) Describe an algorithm {\sc Find-Inversion}$(A)$
	that takes as input an array $A$ and finds an inversion in $O(n)$ time. 
	\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
	\fi 
	\item[(f)] (4 points) Write the loop invariant for the main iteration in your algorithm {\sc Find-Inversion}.  Provide brief arguments about the Initialization, Maintenance, and Usefulness of your loop invariant.
	\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
	\fi 
	\item[(g)] (4 points) Use parts (d) and (e) to design an algorithm
	that sorts an array in time $O(mn)$ where $m$ is the number
	of inversions in the original array. What is the worst-case running time
	of this algorithm?
	\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
	\fi
	
\end{enumerate}

\commentt{

\begin{enumerate}

\item[(g)] (3 points) Let {\sc Rand-Int}$(a,b)$ be an algorithm
that samples uniformly at random an integer value $c$ in the 
range $[a,b]$. Then consider the following randomized
algorithm to find inversion.
\begin{code}
	{\sc Find-Inversion-Randomized}$(A,n)$\\
	\> \For $k=1$ \To $n$\\
	\> \> $i=\textsc{Rand-Int}(1,n)$\\
	\> \> $j=\textsc{Rand-Int}(1,n)$\\
	\> \> \If $i<j$ \&\& $A[i]>A[j]$\\
	\> \> \> \Return $(i,j)$\\
	\> \Return {\sc Find-Inversion}$(A)$
\end{code}
What is the expected run-time of this algorithm if number
of inversions is $m$?
\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
\fi
\item[(h)] (4 points) Now replace the algorithm to find inversion
in part (f) with {\sc Find-Inversion-Randomized}. What
is the worst case, expected runtime of this algorithm?
\hint{Recall that $\sum_{i=1}^{m} 1/i=\log m$.}
\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
\fi \item[(i)] (\textbf{Extra Credit}) (2 points) Show that the worst-case running time of the algorithm
from part (f) is tight by providing an input on which it takes the time derived. 
\ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
\fi
\end{enumerate}

} % end commentt

%=====================================

\newproblem{Asymptotic Comparisons}{10 Points}

\noindent
For each of the following pairs of functions $f(n)$ and $g(n)$, state
whether $f$ is $O(g)$; whether $f$ is $o(g)$; whether $f$ is
$\Theta(g)$; whether $f$ is $\Omega(g)$; and whether $f$ is
$\omega(g)$.  (More than one of these can be true for a single pair!)

\begin{itemize}
   \item[(a)] $f(n) = (n^{n})^{5}$; \quad $g(n)=n^{(n^{5})}$.

  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi

  \item[(b)] $f(n) =\left(\frac{1}{4}\right)^n + 3 n^{17}$; \quad $g(n) = 16^{\log_2 n}$.

  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi

  \item[(c)]  $f(n) = \log(n^{256}+45)$; \quad
  $g(n) = \log(4^{n^2}+5n)$.
  
  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi

 \item[(d)] $f(n) = \frac{5^n}{n+n\log n}$; \quad
  $g(n) =125^{\sqrt{n}}$.

  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi

  \item[(e)] $f(n) = n^{\log n}$; \quad $g(n)=(\log n)^n$.

  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi
\end{itemize}

\ifnum\me<2
\noindent
\textbf{Note to Students:} You do not need to give justifications for your answer. However,
short justifications might be used
to give you partial credit in cases
where your answer is not entirely 
correct.  
\fi



%======================================
\newproblem{Big-O and Exponentiation}{8 points}

\noindent
For parts (a) through (d), let $f(n) = n$, $g(n) = 100n$ and $h(n) = \frac{n}{100}$

\begin{enumerate}
    \item[(a)] (1 point) 
    Prove or disprove: $2^{f(n)} = O(2^{g(n)})$ 
    
  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi
    
    \item[(b)] (2 points)
    Prove or disprove: $2^{f(n)} = O(2^{h(n)})$

  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi

    \item[(c)] (1 point) 
    Prove or disprove: $f(n)! = O(g(n)!)$ 
    
  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi

    \item[(d)] (2 points) 
    Prove or disprove: $f(n)! = O(h(n)!)$ 
    
  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi

    \item[(e)] (2 points) 
    Suppose that $p(n)$ and $q(n)$ are two functions over the non-negative integers where
    \begin{enumerate}
        \item[(i)] $q(n)$ is monotically increasing, that is whenver $n_1 < n_2$ then $q(n_1) < q(n_2)$
        \item[(ii)] $p(n) = O(q(n))$
    \end{enumerate}
    Prove that $\lg (p(n)) = O(\lg (q(n))$

  \ifnum\me<2
\begin{solution}   INSERT YOUR SOLUTION HERE   \end{solution}
  \fi
    
    
\end{enumerate}




\end{document}


